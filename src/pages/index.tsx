/* eslint-disable no-await-in-loop */
import Head from 'next/head';
import {
  SandpackLayout,
  SandpackPreview,
  SandpackPreviewRef,
  SandpackProvider,
  useSandpack,
} from '@codesandbox/sandpack-react';
import {useEffect, useMemo, useRef, useState} from 'react';
import {
  Box,
  Center,
  Container,
  Flex,
  Spinner,
  Stack,
  Text,
  useToast,
} from '@chakra-ui/react';
import {PromptForm} from '@/components/instruction-form';
import {OpenAIChat} from 'langchain/llms/openai';
import {CallbackManager} from 'langchain/callbacks';
import type {SandpackClient} from '@codesandbox/sandpack-client';
import {SandpackToolset} from '@/lib/sandpack-toolset';
import {
  executeSandpackAgent,
  executeSandpackFixerAgent,
} from '@/lib/sandpack-agent';
import {initialCodebaseState} from '@/lib/initial-codebase-state';
import ReactMarkdown from 'react-markdown';

function Page() {
  const {sandpack} = useSandpack();
  const toast = useToast();
  const [thoughtProcess, setThoughtProcess] = useState<string>('');
  const previewRef = useRef<SandpackPreviewRef>(null);
  const sandpackToolset = useRef<SandpackToolset | null>(null);

  useEffect(() => {
    const client = previewRef.current?.getClient();

    if (client && !sandpackToolset.current) {
      sandpackToolset.current = new SandpackToolset(client);
    }
    /**
     * NOTE: In order to make sure that the client will be available
     * use the whole `sandpack` object as a dependency.
     */
  }, [sandpack]);

  const [isLoading, setIsLoading] = useState(false);
  const [instruction, setInstruction] = useState('');

  const handleSubmit = async (errorFix?: boolean) => {
    setIsLoading(true);
    try {
      if (!sandpackToolset.current) {
        throw new Error('Sandpack toolset not initialized');
      }
      setThoughtProcess('');
      if (errorFix) {
        if (!sandpack.error) {
          throw new Error('No error to fix');
        }

        await executeSandpackFixerAgent(
          sandpack.error,
          sandpackToolset.current,
          {
            onNewToken: (token) => {
              setThoughtProcess((prev) => `${prev}${token}`);
            },
          },
        );
      } else {
        await executeSandpackAgent(instruction, sandpackToolset.current, {
          onNewToken: (token) => {
            setThoughtProcess((prev) => `${prev}${token}`);
          },
        });
      }
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error(error);
      toast({
        title: 'An error occurred.',
        description:
          'Something went wrong, please check your instruction and try again.',
        status: 'error',
        duration: 9000,
        isClosable: true,
      });
    }
    setIsLoading(false);
  };

  return (
    <Box h="100vh" bg="black">
      <Container
        maxW="container.xl"
        h="100vh"
        display="flex"
        position="relative"
        flexDirection="column"
        maxH="100vh"
        p={8}
      >
        <Flex flex={1} h="100%" position="relative">
          <Flex flex={1} direction="column" position="relative">
            <Stack spacing={4} direction="row" h="100%" position="relative">
              <SandpackLayout style={{height: '100%', width: '100%'}}>
                <SandpackPreview
                  ref={previewRef}
                  style={{
                    height: '100%',
                  }}
                />
              </SandpackLayout>
              <Box
                color="white"
                w="300px"
                bg="gray.900"
                h="100%"
                p={4}
                fontFamily="mono"
                borderRadius="md"
                overflowY="scroll"
              >
                <Text fontSize="sm" color="white">
                  {/* <ReactMarkdown>{thoughtProcess || '...'}</ReactMarkdown> */}
                </Text>
              </Box>
            </Stack>
            <PromptForm
              isLoading={isLoading}
              onChange={(newInstruction) => setInstruction(newInstruction)}
              onSubmit={() => handleSubmit()}
              instruction={instruction}
              // TODO
              onFix={() => handleSubmit(true)}
              errorMessage={sandpack.error?.message || ''}
            />
          </Flex>
        </Flex>
      </Container>
      {sandpack.status !== 'running' && (
        <Center
          h="100vh"
          w="100vw"
          position="absolute"
          top={0}
          left={0}
          bg="white"
          zIndex="overlay"
          display="flex"
          flexDirection="column"
        >
          <Spinner size="lg" />
          <Text fontSize="lg" mt={4}>
            Starting session
          </Text>
        </Center>
      )}
    </Box>
  );
}

export default function Home() {
  return (
    <>
      <Head>
        <title>ReactGPT</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <SandpackProvider
        template="react"
        customSetup={{
          dependencies: {
            ...initialCodebaseState.dependencies,
          },
        }}
        files={initialCodebaseState.files}
      >
        <Page />
      </SandpackProvider>
    </>
  );
}
